<!DOCTYPE html>
<html>
<head>
    <title>Audio Processor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            box-sizing: border-box;
        }
        html, body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            background-color: #212121;
            color: #e0e0e0; 
            text-align: center; 
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for scrolling */
            height: 100%;
            width: 100%;
            overflow-y: auto; /* Allow scrolling on small screens */
            margin: 0;
            padding: 20px 10px;
        }
        #shushMessage {
            display: none; 
            font-size: 3em; 
            font-weight: bold;
            color: #C62828;
            margin-top: 10px;
            animation: fadeIn 0.5s;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        #mainContainer { display: flex; flex-direction: column; align-items: center; width: 100%;}
        #startButton {
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 8px;
            border: none;
            background-color: #00796B;
            color: white;
            margin-bottom: 20px;
        }
        #visualizerContainer {
            width: 80px;
            height: 150px;
            background-color: #333;
            border: 2px solid #555;
            border-radius: 8px;
            margin: 10px auto;
            position: relative;
            overflow: hidden;
        }
        #soundBar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #4A90E2, #F5A623);
            transition: height 0.1s linear;
        }
        #triggerLine {
            position: absolute;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: #BDBDBD;
            bottom: 50%;
            transition: bottom 0.2s ease;
        }
        .controls { margin-top: 15px; width: 90%; max-width: 300px; }
        .control-group { margin-bottom: 10px; text-align: left; }
        .control-group label { display: block; margin-bottom: 5px; font-size: 0.9em; }
        .control-group input[type="range"] { width: 100%; }
        .status-display { margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="mainContainer">
        <button id="startButton">Start Monitoring (v3.2)</button>
        <div id="mainContent" style="width: 100%;">
             <div class="status-display">Detected Sound: <span id="soundLevelValue">0</span></div>
             <div class="status-display">Replay Volume: <span id="replayVolumeValue">0</span></div>
             <div class="status-display">Time Remaining: <span id="timeRemainingValue">-</span></div>
            <div id="visualizerContainer">
                <div id="soundBar"></div>
                <div id="triggerLine"></div>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label for="triggerSlider">Disturbance Trigger: <span id="triggerValue">50</span></label>
                    <input type="range" id="triggerSlider" min="10" max="95" value="50">
                </div>
                <div class="control-group">
                    <label for="volumeSlider">Target Volume: <span id="volumeValue">50%</span></label>
                    <input type="range" id="volumeSlider" min="0" max="100" value="50">
                </div>
                <div class="control-group">
                    <label for="sensitivitySlider">Sound Sensitivity: <span id="sensitivityValue">50</span></label>
                    <input type="range" id="sensitivitySlider" min="1" max="100" value="50">
                </div>
                 <div class="control-group">
                    <label for="durationSlider">Decay Duration: <span id="durationValue">30s</span></label>
                    <input type="range" id="durationSlider" min="1" max="100" value="25">
                </div>
                 <div class="control-group">
                    <label for="rampSlider">Ramp Period: <span id="rampValue">4s</span></label>
                    <input type="range" id="rampSlider" min="1" max="10" value="4">
                </div>
                 <div class="control-group">
                    <label for="oscillationSlider">Oscillation Period: <span id="oscillationValue">9s</span></label>
                    <input type="range" id="oscillationSlider" min="2" max="20" value="9">
                </div>
                <div class="control-group">
                    <label for="oscillationDepthSlider">Oscillation Depth: <span id="oscillationDepthValue">10%</span></label>
                    <input type="range" id="oscillationDepthSlider" min="0" max="100" value="10">
                </div>
            </div>
            <div id="shushMessage">Shusssshhhhh</div>
        </div>
    </div>
    
    <script>
        // --- SECTION 1: DOM ELEMENT REFERENCES ---
        const startButton = document.getElementById('startButton');
        const triggerSlider = document.getElementById('triggerSlider');
        const volumeSlider = document.getElementById('volumeSlider');
        const sensitivitySlider = document.getElementById('sensitivitySlider');
        const durationSlider = document.getElementById('durationSlider');
        const rampSlider = document.getElementById('rampSlider');
        const oscillationSlider = document.getElementById('oscillationSlider');
        const oscillationDepthSlider = document.getElementById('oscillationDepthSlider');
        const triggerValueSpan = document.getElementById('triggerValue');
        const volumeValueSpan = document.getElementById('volumeValue');
        const sensitivityValueSpan = document.getElementById('sensitivityValue');
        const durationValueSpan = document.getElementById('durationValue');
        const rampValueSpan = document.getElementById('rampValue');
        const oscillationValueSpan = document.getElementById('oscillationValue');
        const oscillationDepthValueSpan = document.getElementById('oscillationDepthValue');
        const triggerLine = document.getElementById('triggerLine');
        const soundLevelValue = document.getElementById('soundLevelValue');
        const replayVolumeValue = document.getElementById('replayVolumeValue');
        const timeRemainingValue = document.getElementById('timeRemainingValue');

        // --- SECTION 2: CONFIGURATION & STATE VARIABLES ---
        let disturbanceTriggerLevel = 50;
        let soundSensitivity = 50;
        let targetVolume = 0.5;
        let decayDuration = 30;
        let rampPeriod = 4;
        let oscillationPeriod = 9;
        let oscillationDepth = 0.1;
        let isMonitoring = false;
        let animationFrameId = null;
        let breachRecords = [];
        let isShushing = false;
        let allTimeouts = [];
        let decayEndTime = null;
        
        // --- SECTION 3: AUDIO API & STATE VARIABLES ---
        let audioContext;
        let streamSource;
        let whiteNoiseNode = null;
        let lfoNode = null;
        let lfoGain = null;
        let masterGainNode = null;
        let audioState = 'idle'; // 'idle', 'rampingUp', 'holdingAfterRampUp', 'decaying', 'holdingAfterInterrupt'

        // --- SECTION 4: EVENT LISTENERS ---
        startButton.addEventListener('click', () => {
            if (isMonitoring) {
                stopMonitoring();
            } else {
                startMonitoring();
            }
        });

        triggerSlider.addEventListener('input', (e) => {
            disturbanceTriggerLevel = parseInt(e.target.value);
            triggerValueSpan.textContent = disturbanceTriggerLevel;
            triggerLine.style.bottom = `${disturbanceTriggerLevel}%`;
        });

        volumeSlider.addEventListener('input', (e) => {
            const newVolume = parseInt(e.target.value);
            targetVolume = newVolume / 100;
            volumeValueSpan.textContent = `${newVolume}%`;
            if (lfoGain) {
                lfoGain.gain.setTargetAtTime(targetVolume * oscillationDepth, audioContext.currentTime, 0.5);
            }
        });

        sensitivitySlider.addEventListener('input', (e) => {
            soundSensitivity = 101 - parseInt(e.target.value);
            sensitivityValueSpan.textContent = e.target.value;
        });
        
        durationSlider.addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            const minSec = 5; const maxSec = 1800;
            const minLog = Math.log(minSec); const maxLog = Math.log(maxSec);
            const scale = (maxLog - minLog) / 99;
            decayDuration = Math.exp(minLog + scale * (sliderValue - 1));
            durationValueSpan.textContent = decayDuration < 60 ? `${Math.round(decayDuration)}s` : `${Math.round(decayDuration / 60)}m`;
        });
        
        rampSlider.addEventListener('input', (e) => {
            rampPeriod = parseInt(e.target.value);
            rampValueSpan.textContent = `${rampPeriod}s`;
        });

        oscillationSlider.addEventListener('input', (e) => {
            oscillationPeriod = parseInt(e.target.value);
            oscillationValueSpan.textContent = `${oscillationPeriod}s`;
            if (lfoNode) {
                lfoNode.frequency.setTargetAtTime(1 / oscillationPeriod, audioContext.currentTime, 0.1);
            }
        });

        oscillationDepthSlider.addEventListener('input', (e) => {
            const depthPercentage = parseInt(e.target.value);
            oscillationDepth = depthPercentage / 100;
            oscillationDepthValueSpan.textContent = `${depthPercentage}%`;
            if(lfoGain) {
                lfoGain.gain.setTargetAtTime(targetVolume * oscillationDepth, audioContext.currentTime, 0.5);
            }
        });


        // --- SECTION 5: CORE LOGIC ---
        async function startMonitoring() {
            if (isMonitoring) return;
            isMonitoring = true;
            startButton.textContent = 'Stop Monitoring';
            startButton.style.backgroundColor = '#C62828';

            try {
                audioContext = new AudioContext();
                // Request mic with echo cancellation to prevent feedback loop
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }, 
                    video: false 
                });
                streamSource = stream;
                
                const mediaStreamSource = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                mediaStreamSource.connect(analyser);
                const dataArray = new Uint8Array(analyser.frequencyBinCount);

                function mainLoop() {
                    analyser.getByteFrequencyData(dataArray);
                    
                    const scaledVolume = calculateLogVolume(dataArray);
                    soundLevelValue.textContent = scaledVolume;
                    
                    if (scaledVolume > soundSensitivity) {
                        breachRecords.push({ timestamp: Date.now(), magnitude: scaledVolume - soundSensitivity });
                    }

                    const disturbanceLevel = calculateDisturbanceLevel();
                    document.getElementById('soundBar').style.height = `${disturbanceLevel}%`;

                    if (masterGainNode) {
                        replayVolumeValue.textContent = Math.round(masterGainNode.gain.value * 100);
                    } else {
                        replayVolumeValue.textContent = 0;
                    }
                    
                    // Update countdown timer
                    if (audioState === 'decaying' && decayEndTime) {
                        const remaining = Math.max(0, (decayEndTime - Date.now()) / 1000);
                        timeRemainingValue.textContent = `${remaining.toFixed(1)}s`;
                    } else {
                        timeRemainingValue.textContent = '-';
                    }

                    if (disturbanceLevel > disturbanceTriggerLevel) {
                        triggerSoundPlayback();
                        if (!isShushing) {
                           showShushMessage();
                        }
                    }
                    animationFrameId = requestAnimationFrame(mainLoop);
                }
                mainLoop();
            
            } catch (err) {
                console.error('Error:', err);
                stopMonitoring();
            }
        }

        function stopMonitoring() {
            if (!isMonitoring) return;

            cancelAnimationFrame(animationFrameId);
            clearAllTimeouts();
            
            // Immediate sound stop logic
            if (whiteNoiseNode) { try { whiteNoiseNode.stop(0); whiteNoiseNode.disconnect(); } catch (e) {} }
            if (lfoNode) { try { lfoNode.stop(0); lfoNode.disconnect(); } catch (e) {} }
            if (lfoGain) { try { lfoGain.disconnect(); } catch (e) {} }
            if (masterGainNode) { try { masterGainNode.disconnect(); } catch (e) {} }
            
            whiteNoiseNode = lfoNode = lfoGain = masterGainNode = null;
            audioState = 'idle';
            
            if (streamSource) {
                streamSource.getTracks().forEach(track => track.stop());
            }

            isMonitoring = false;
            breachRecords = [];
            animationFrameId = null;
            streamSource = null;
            decayEndTime = null;
            
            startButton.textContent = `Start Monitoring (v3.2)`;
            startButton.style.backgroundColor = '#00796B';
        }

        // --- SECTION 6: SMOOTH AUDIO ENGINE (RAMP UP & DECAY MODEL) ---
        function triggerSoundPlayback() {
            const now = audioContext.currentTime;
            
            if (audioState === 'idle') {
                audioState = 'rampingUp';
                createAudioNodes();
                masterGainNode.gain.setValueAtTime(0.0001, now);
                masterGainNode.gain.linearRampToValueAtTime(targetVolume, now + rampPeriod);
                
                scheduleTimeout(() => {
                    if (audioState === 'rampingUp') {
                        audioState = 'holdingAfterRampUp';
                        scheduleTimeout(() => {
                            if (audioState === 'holdingAfterRampUp') {
                                startDecay();
                            }
                        }, 1000);
                    }
                }, rampPeriod * 1000);
            }
            else if (audioState === 'decaying') {
                audioState = 'holdingAfterInterrupt';
                clearAllTimeouts();

                masterGainNode.gain.cancelScheduledValues(now);
                if (lfoGain.numberOfOutputs > 0) { try { lfoGain.disconnect(masterGainNode.gain); } catch(e) {} }
                masterGainNode.gain.setValueAtTime(masterGainNode.gain.value, now);

                scheduleTimeout(() => {
                    if (audioState === 'holdingAfterInterrupt') {
                        audioState = 'rampingUp';
                        const rampUpStartTime = audioContext.currentTime;
                        masterGainNode.gain.linearRampToValueAtTime(targetVolume, rampUpStartTime + rampPeriod);
                        
                        scheduleTimeout(() => {
                            if (audioState === 'rampingUp') {
                                audioState = 'holdingAfterRampUp';
                                scheduleTimeout(() => {
                                    if (audioState === 'holdingAfterRampUp') {
                                        startDecay();
                                    }
                                }, 1000);
                            }
                        }, rampPeriod * 1000);
                    }
                }, 1000);
            }
        }
        
        function startDecay() {
            audioState = 'decaying';
            decayEndTime = Date.now() + decayDuration * 1000;
            const now = audioContext.currentTime;

            masterGainNode.gain.setValueAtTime(targetVolume, now);
            masterGainNode.gain.linearRampToValueAtTime(0.0001, now + decayDuration);

            lfoGain.connect(masterGainNode.gain);
            lfoGain.gain.linearRampToValueAtTime(0, now + decayDuration);
            
            scheduleTimeout(cleanupAudioNodes, (decayDuration + 1) * 1000);
        }

        function createAudioNodes() {
            masterGainNode = audioContext.createGain();
            masterGainNode.connect(audioContext.destination);

            const bufferSize = 2 * audioContext.sampleRate;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
            whiteNoiseNode = audioContext.createBufferSource();
            whiteNoiseNode.buffer = noiseBuffer;
            whiteNoiseNode.loop = true;
            whiteNoiseNode.connect(masterGainNode);

            lfoNode = audioContext.createOscillator();
            lfoNode.type = 'sine';
            lfoNode.frequency.setValueAtTime(1 / oscillationPeriod, audioContext.currentTime);
            lfoGain = audioContext.createGain();
            lfoGain.gain.setValueAtTime(targetVolume * oscillationDepth, audioContext.currentTime);
            lfoNode.connect(lfoGain);

            whiteNoiseNode.start(audioContext.currentTime);
            lfoNode.start(audioContext.currentTime);
        }

        function cleanupAudioNodes() {
            if (!['decaying', 'idle'].includes(audioState) && audioState !== 'idle') return;
            decayEndTime = null;

            if (whiteNoiseNode) { try { whiteNoiseNode.stop(0); whiteNoiseNode.disconnect(); } catch (e) {} }
            if (lfoNode) { try { lfoNode.stop(0); lfoNode.disconnect(); } catch (e) {} }
            if (lfoGain) { try { lfoGain.disconnect(); } catch (e) {} }
            if (masterGainNode) { try { masterGainNode.disconnect(); } catch (e) {} }
            
            whiteNoiseNode = lfoNode = lfoGain = masterGainNode = null;
            audioState = 'idle';
        }
        
        // --- SECTION 7: HELPER FUNCTIONS ---
        function scheduleTimeout(callback, delay) {
            const id = setTimeout(callback, delay);
            allTimeouts.push(id);
            return id;
        }

        function clearAllTimeouts() {
            allTimeouts.forEach(clearTimeout);
            allTimeouts = [];
        }

        function calculateLogVolume(dataArray) {
            let sum = 0;
            for (const amplitude of dataArray) { sum += amplitude * amplitude; }
            const rawVolume = Math.sqrt(sum / dataArray.length);
            return Math.min(100, Math.round(18 * Math.log(rawVolume + 1)));
        }

        function calculateDisturbanceLevel() {
            const now = Date.now();
            const tenSecondsAgo = now - 10000;
            breachRecords = breachRecords.filter(record => record.timestamp > tenSecondsAgo);
            if (breachRecords.length === 0) { return 0; }
            let totalScore = 0;
            for (const record of breachRecords) {
                const recencyWeight = (record.timestamp - tenSecondsAgo) / 10000;
                totalScore += record.magnitude * recencyWeight;
            }
            const scoreAsPercentage = Math.min(1.0, totalScore / 5000);
            const curvedScore = Math.pow(scoreAsPercentage, 2.0);
            return Math.round(curvedScore * 100);
        }

        function showShushMessage() {
            isShushing = true; 
            document.getElementById('shushMessage').style.display = 'block';
            setTimeout(() => {
                document.getElementById('shushMessage').style.display = 'none';
                isShushing = false;
            }, 10000);
        }
    </script>
</body>
</html>




